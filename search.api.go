// Code generated by protoc-gen-go_api(github.com/dev-openapi/protoc-gen-go_api version=v1.0.3). DO NOT EDIT.
// source: douyin-miniapp/search.proto

package douyin_miniapp

import (
	context "context"
	fmt "fmt"
	io "io"
	json "encoding/json"
	bytes "bytes"
	http "net/http"
	strings "strings"
	url "net/url"
)
// Reference imports to suppress errors if they are not otherwise used.
var _ = context.Background
var _ = http.NewRequest
var _ = io.Copy
var _ = bytes.Compare
var _ = json.Marshal
var _ = strings.Compare
var _ = fmt.Errorf
var _ = url.Parse


// Client API for Search service

type SearchService interface {
	// CreateMaSubService  创建抖音搜索直达子服务 header带access-token https://developer.open-douyin.com/docs/resource/zh-CN/mini-app/develop/server/search/create-ma-sub-service
	CreateMaSubService(ctx context.Context, in *CreateMaSubServiceReq, opts ...Option) (*CreateMaSubServiceRes, error)
	// QueryMaSubService  查询已创建的抖音搜索直达子服务列表 header带access_token https://developer.open-douyin.com/docs/resource/zh-CN/mini-app/develop/server/search/query-ma-sub-service
	QueryMaSubService(ctx context.Context, in *QueryMaSubServiceReq, opts ...Option) (*QueryMaSubServiceRes, error)
	// DeleteMaSubService  删除抖音搜索直达子服务 header带access_token https://developer.open-douyin.com/docs/resource/zh-CN/mini-app/develop/server/search/delete-ma-sub-service
	DeleteMaSubService(ctx context.Context, in *DeleteMaSubServiceReq, opts ...Option) (*DeleteMaSubServiceRes, error)
	// CheckMaSubService  校验是否有搜索直达服务的创建权限 header带access_token https://developer.open-douyin.com/docs/resource/zh-CN/mini-app/develop/server/search/check-permission
	CheckMaSubService(ctx context.Context, in *CheckMaSubServiceReq, opts ...Option) (*CheckMaSubServiceRes, error)
}

type searchService struct {
	// opts
	opts *Options
}

func NewSearchService(opts ...Option) SearchService {
	opt := newOptions(opts...)
	if len(opt.addr) <= 0 {
		opt.addr = "https://developer.toutiao.com"
	}
	return &searchService {
		opts: opt,
	}
}


func (c *searchService) CreateMaSubService(ctx context.Context, in *CreateMaSubServiceReq, opts ...Option) (*CreateMaSubServiceRes, error) {
	var res CreateMaSubServiceRes
	// options
	opt := buildOptions(c.opts, opts...)
	headers := make(map[string]string)
	// route
	rawURL := fmt.Sprintf("%s/api/apps/v1/capacity/create_ma_sub_service", opt.addr)

	// body
	var body io.Reader
	bs, err := json.Marshal(in)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(bs)
	headers["Content-Type"] = "application/json"

	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}
	
	// header
	for k, v := range headers {
		req.Header.Set(k, v)
	}
	resp, err := opt.DoRequest(ctx, opt.client, req)
	if err != nil {
		return nil, err
	}
	err = opt.DoResponse(ctx, resp, &res)
	return &res, err 

}

func (c *searchService) QueryMaSubService(ctx context.Context, in *QueryMaSubServiceReq, opts ...Option) (*QueryMaSubServiceRes, error) {
	var res QueryMaSubServiceRes
	// options
	opt := buildOptions(c.opts, opts...)
	headers := make(map[string]string)
	// route
	rawURL := fmt.Sprintf("%s/api/apps/v1/capacity/query_ma_sub_service", opt.addr)

	// body
	var body io.Reader
	
	req, err := http.NewRequest("GET", rawURL, body)
	if err != nil {
		return nil, err
	}
	
	params := req.URL.Query()
	if in.GetApprovalState() != 0 {
		params.Add("approval_state", fmt.Sprintf("%v", in.GetApprovalState()))
	}
	if in.GetPageNo() != 0 {
		params.Add("page_no", fmt.Sprintf("%v", in.GetPageNo()))
	}
	if in.GetPageSize() != 0 {
		params.Add("page_size", fmt.Sprintf("%v", in.GetPageSize()))
	}	
	req.URL.RawQuery = params.Encode()
	
	// header
	for k, v := range headers {
		req.Header.Set(k, v)
	}
	resp, err := opt.DoRequest(ctx, opt.client, req)
	if err != nil {
		return nil, err
	}
	err = opt.DoResponse(ctx, resp, &res)
	return &res, err 

}

func (c *searchService) DeleteMaSubService(ctx context.Context, in *DeleteMaSubServiceReq, opts ...Option) (*DeleteMaSubServiceRes, error) {
	var res DeleteMaSubServiceRes
	// options
	opt := buildOptions(c.opts, opts...)
	headers := make(map[string]string)
	// route
	rawURL := fmt.Sprintf("%s", opt.addr)

	// body
	var body io.Reader
	
	req, err := http.NewRequest("", rawURL, body)
	if err != nil {
		return nil, err
	}
	
	params := req.URL.Query()
	if in.GetSubServiceId() != "" {
		params.Add("sub_service_id", fmt.Sprintf("%v", in.GetSubServiceId()))
	}	
	req.URL.RawQuery = params.Encode()
	
	// header
	for k, v := range headers {
		req.Header.Set(k, v)
	}
	resp, err := opt.DoRequest(ctx, opt.client, req)
	if err != nil {
		return nil, err
	}
	err = opt.DoResponse(ctx, resp, &res)
	return &res, err 

}

func (c *searchService) CheckMaSubService(ctx context.Context, in *CheckMaSubServiceReq, opts ...Option) (*CheckMaSubServiceRes, error) {
	var res CheckMaSubServiceRes
	// options
	opt := buildOptions(c.opts, opts...)
	headers := make(map[string]string)
	// route
	rawURL := fmt.Sprintf("%s/api/apps/v1/capacity/check_ma_sub_service", opt.addr)

	// body
	var body io.Reader
	
	req, err := http.NewRequest("GET", rawURL, body)
	if err != nil {
		return nil, err
	}
	
	// header
	for k, v := range headers {
		req.Header.Set(k, v)
	}
	resp, err := opt.DoRequest(ctx, opt.client, req)
	if err != nil {
		return nil, err
	}
	err = opt.DoResponse(ctx, resp, &res)
	return &res, err 

}
